#include "ass6_12CS30006_translator.h"
#include "y.tab.h"
extern int yydebug;
extern char * yytext;

extern void yyerror(const char *);
extern int yylex();

// Variables

// count of temporary variables
int tempCount = 0;
// current symbol table
symTable * currentSymTab = new symTable();
// global symbol table
symTable * globalSymTab  = new symTable("ST (global)");
// the list of all quads to be generated by the program
quadList quad;

vector <string> strLabels;
map <string, int> uniqueLabels;

// Type definitions

type_t::type_t() {}

// constructor with basic type
type_t::type_t(basicType b) {
    bType = b;
    size = 1;
    next = NULL;
    if(b <= t_DOUBLE) size = this->getSize();
}

// copy constructor
type_t::type_t(const type_t & t) {
    type_t * ptr1 = (type_t *)this;
    type_t * ptr2 = (type_t *)&t;
    ptr1->bType = ptr2->bType;
    ptr1->size = ptr2->size;
    while(ptr2 != NULL) {
        ptr1->bType = ptr2->bType;
        ptr1->size = ptr2->size;
        ptr2 = ptr2->next;
        if(ptr2 == NULL) ptr1->next = NULL;
        else ptr1->next = new type_t();
        ptr1 = ptr1->next;
    }
    assert(ptr1 == NULL && ptr2 == NULL);
}

// recursively get size of current object
int type_t::getSize() {
    switch(bType) {
        case (t_INT):
            return SIZE_OF_INT;
        case (t_CHAR):
            return SIZE_OF_CHAR;
        case (t_VOID):
            return SIZE_OF_VOID;
        case (t_DOUBLE):
            return SIZE_OF_DOUBLE;
        case (t_FUNC):
            return SIZE_OF_FUNC;
        case (t_PTR):
            return SIZE_OF_PTR;
        case (t_BOOL):
            return SIZE_OF_BOOL;
        case (t_ARR):
            return size * next->getSize();
        default:
            yyerror("Unknown type");
            exit(1);
    }
}

// recursively print the current type
void type_t::print() {
    switch(bType) {
        case (t_INT):
            printf("int");
            return;
        case (t_DOUBLE):
            printf("double");
            return;
        case (t_CHAR):
            printf("char");
            return;
        case (t_VOID):
            printf("void");
            return;
        case (t_BOOL):
            printf("bool");
            return;
        case (t_PTR):
            printf("ptr(");
            next->print();
            printf(")");
            return;
        case (t_FUNC):
            printf("func");
            return;
        case (t_ARR):
            printf("array(%d, ", size);
            next->print();
            printf(")");
            return;
        default:
            printf("Error ! Unknown type found !\n");
            exit(-1);
    }
}

// check if two type_t t1 and t2 are equal
bool areEqual(type_t * t1, type_t * t2) {
    type_t * ptr1 = t1;
    type_t * ptr2 = t2;
    while(ptr1 != NULL and ptr2 != NULL) {
        if(ptr1->bType != ptr2->bType) return false;
        ptr1 = ptr1->next;
        ptr2 = ptr2->next;
    }
    if(ptr1 == NULL && ptr2 == NULL) return true;
    else {
        yyerror("Incompatible types");
        exit(1);
    }
    return false;
}

// Symbol Entry Definitions

// constructor with scope
symEntry::symEntry(string s) {
    nestedTable = NULL;
    wasInitialised = false;
    scope = s;
}

// default constructor
symTable::symTable() {
    offset = 0;
}

// constructor with the name of symbol table
symTable::symTable(string s) {
    name = s;
    offset = 0;
}

// search a string in the symbol table
// if found return the pointer to the entry
// else create a new entry for current string and return its pointer
symEntry * symTable::lookUp(string name) {
    for(int i = 0; i < (int)entries.size(); ++i) {
        if(entries[i]->name.length() != 0 && name == entries[i]->name) {
            return entries[i];
        }
    }
    symEntry * sym = new symEntry();
    sym->name = name;
    entries.push_back(sym);
    return sym;
}

// check if a string is present in a symbol table
bool symTable::isPresent(string name) {
    for(int i = 0; i < (int)entries.size(); ++i) {
        if(entries[i]->name.length() != 0 && name == entries[i]->name) {
            return true;
        }
    }
    return false;
}

// generate a temporary variable of given type
symEntry * symTable::genTemp(type_t * type) {
    symEntry * sym = new symEntry("temp");
    char tmp[10];
    // give this variable a unique name
    sprintf(tmp, "t%03d", tempCount);
    ++tempCount;
    sym->name = tmp;
    sym->type = type;
    int curSz = 0;
    switch(type->bType) {
        case (t_INT):
            curSz = SIZE_OF_INT;
            break;
        case (t_CHAR):
            curSz = SIZE_OF_CHAR;
            break;
        case (t_DOUBLE):
            curSz = SIZE_OF_DOUBLE;
            break;
        case (t_PTR):
            curSz = SIZE_OF_PTR;
            break;
        default:
            curSz = 0;
    }
    // update size and offset
    sym->size = curSz;
    sym->offset = offset;
    offset += curSz;
    // add it to the list of entries
    entries.push_back(sym);
    return sym;
}

// print all the fields of the entry of symbol table
void symEntry::print() {
    printf("%10s\t", this->name.c_str());
    printf("\t");
    if(this->wasInitialised) {
        switch(this->type->bType) {
            case (t_INT):
                printf("%5d", this->init.intVal);
                break;
            case (t_CHAR):
                printf("%5c", this->init.charVal);
                break;
            case (t_DOUBLE):
                printf("%5.3lf", this->init.doubleVal);
                break;
            default:
                printf("Invalid Type");
        }
    }
    else printf(" NULL");
    printf("%5d", this->size);
    printf("%5d", this->offset);
    printf("%10s", this->scope.c_str());
    if(this->nestedTable != NULL) printf("%20s\t", this->nestedTable->name.c_str());
    else printf("%15s\t", "NULL");
    this->type->print();
    puts("");
}

// Update the type and size of an entry
void symTable::update(symEntry * s, type_t * t, int sz) {
    s->type = t;
    s->size = sz;
    s->offset = offset;
    offset += s->size;
    if(t->bType == t_FUNC) s->scope = "global";
}

// Update the initial value of a symbol entry
void symTable::update(symEntry * s, initialVal init) {
    s->init = init;
    s->wasInitialised = true;
}

// print all the entries of the symbol table
void symTable::print() {
    printf("%s:\n", name.c_str());
    for(int i = 0; i < (int)entries.size(); ++i) {
        entries[i]->print();
    }
    puts("");
}

// constructors of quad entries
quadEntry::quadEntry(opcodeType o, string s1, string s2, string s3) : op(o), result(s1), arg1(s2), arg2(s3) {}

quadEntry::quadEntry(opcodeType o, string s1, int n) : op(o), result(s1), arg2("") {
    char buf[10];
    sprintf(buf, "%d", n);
    arg1 = buf;
}

quadEntry::quadEntry(opcodeType o, string s1, char c) : op(o), result(s1), arg2("") {
    char buf[10];
    sprintf(buf, "%d", (int)c);
    arg1 = buf;
}

quadEntry::quadEntry(opcodeType o, string s1, double d) : op(o), result(s1), arg2("") {
    char buf[10];
    sprintf(buf, "%lf", d);
    arg1 = buf;
}

// add the quad to the list
void quadList::emit(quadEntry q) {
    // add the quad and increase the next instruction
    this->quad_v.push_back(q);
    this->nextInstr++;
}

// Set the result field of the current symbol 
void quadEntry::setTarget(int addr) {
    char tmp[10];
    sprintf(tmp, "%d", addr);
    string stmp(tmp);
    this->result = stmp;
}

// print the quad entry accoring to the opcode
void quadEntry::print(FILE * out) {
    switch(op) {
        case(OP_PLUS):
            fprintf(out, "%s = %s + %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(OP_MINUS):
            fprintf(out, "%s = %s - %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(OP_MULT):
            fprintf(out, "%s = %s * %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(OP_DIV):
            fprintf(out, "%s = %s / %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(OP_MOD):
            fprintf(out, "%s = %s %% %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(OP_UMINUS):
            fprintf(out, "%s = -%s\n", result.c_str(), arg1.c_str());
            break;
        case(OP_COPY):
            fprintf(out, "%s = %s\n", result.c_str(), arg1.c_str());
            break;
        case(OP_T):
            fprintf(out, "if (%s) goto %s\n", arg1.c_str(), result.c_str());
            break;
        case(OP_F):
            fprintf(out, "ifFalse (%s) goto %s\n", arg1.c_str(), result.c_str());
            break;
        case(OP_LT):
            fprintf(out, "if (%s < %s) goto %s\n", arg1.c_str(), arg2.c_str(), result.c_str());
            break;
        case(OP_LTE):
            fprintf(out, "if (%s <= %s) goto %s\n", arg1.c_str(), arg2.c_str(), result.c_str());
            break;
        case(OP_GT):
            fprintf(out, "if (%s > %s) goto %s\n", arg1.c_str(), arg2.c_str(), result.c_str());
            break;
        case(OP_GTE):
            fprintf(out, "if (%s >= %s) goto %s\n", arg1.c_str(), arg2.c_str(), result.c_str());
            break;
        case(OP_EQ):
            fprintf(out, "if (%s == %s) goto %s\n", arg1.c_str(), arg2.c_str(), result.c_str());
            break;
        case(OP_NEQ):
            fprintf(out, "if (%s != %s) goto %s\n", arg1.c_str(), arg2.c_str(), result.c_str());
            break;
        case(OP_INT2DBL):
            fprintf(out, "%s = int2dbl(%s)\n", result.c_str(), arg1.c_str());
            break;
        case(OP_DBL2INT):
            fprintf(out, "%s = dbl2int(%s)\n", result.c_str(), arg1.c_str());
            break;
        case(OP_INT2CHAR):
            fprintf(out, "%s = int2char(%s)\n", result.c_str(), arg1.c_str());
            break;
        case(OP_CHAR2INT):
            fprintf(out, "%s = char2int(%s)\n", result.c_str(), arg1.c_str());
            break;
        case(OP_L_VAL_AT):
            fprintf(out, "* %s = %s\n", result.c_str(), arg1.c_str());
            break;
        case(OP_R_VAL_AT):
            fprintf(out, "%s = * %s\n", result.c_str(), arg1.c_str());
            break;
        case(OP_L_INDEX):
            fprintf(out, "%s[%s] = %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(OP_R_INDEX):
            fprintf(out, "%s = %s[%s]\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(OP_ADDR):
            fprintf(out, "%s = & %s\n", result.c_str(), arg1.c_str());
            break;
        case(OP_PARAM):
            fprintf(out, "param %s\n", result.c_str());
            break;
        case(OP_GOTO_O):
            fprintf(out, "goto %s\n", result.c_str());
            break;
        case(OP_CALL):
            fprintf(out, "%s = call %s, %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(OP_RETURN):
            fprintf(out, "return\n");
            break;
        case(OP_RETURN_VAL):
            fprintf(out, "return %s\n", result.c_str());
            break;
        case(OP_BW_NOT):
            fprintf(out, "%s = ~ %s\n", result.c_str(), arg1.c_str());
            break;
        case(OP_SHL):
            fprintf(out, "%s = %s << %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(OP_SHR):
            fprintf(out, "%s = %s >> %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(OP_BW_AND):
            fprintf(out, "%s = %s & %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(OP_BW_XOR):
            fprintf(out, "%s = %s ^ %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(OP_BW_OR):
            fprintf(out, "%s = %s | %s\n", result.c_str(), arg1.c_str(), arg2.c_str());
            break;
        case(OP_FUNC_START):
            fprintf(out, "%s Starts\n", result.c_str());
            break;
        case(OP_FUNC_END):
            fprintf(out, "%s Ends\n", result.c_str());
            break;
        default:
            fprintf(out, "Error ! Unknown opcodeType.\n");
            exit(-1);
    }
}

// print the quad entry accoring to the opcode
void quadEntry::genTargetCode(FILE * out) {
    switch(op) {
        case(OP_PLUS):
            {
                symEntry * res = currentSymTab->lookUp(result);
                symEntry * op1 = currentSymTab->lookUp(arg1);
                if(currentSymTab->isPresent(arg2)) {
                    symEntry * op2 = currentSymTab->lookUp(arg2);
                    if(op1->type->bType == t_ARR) {
                        fprintf(out, "\tleal\t%d(%%ebp), %%eax\n", op1->offset);
                        fprintf(out, "\tmovl\t%d(%%ebp), %%edx\n", op2->offset);
                        fprintf(out, "\taddl\t%%edx, %%eax\n");
                        fprintf(out, "\tmovl\t%%eax, %d(%%ebp)\n", res->offset);
                    } else {
                        if(res->type->bType == t_CHAR) {
                            fprintf(out, "\tmovzbl\t%d(%%ebp), %%eax\n", op1->offset);
                            fprintf(out, "\tmovzbl\t%d(%%ebp), %%edx\n", op2->offset);
                            fprintf(out, "\taddl\t%%edx, %%eax\n");
                            fprintf(out, "\tmovb\t%%al, %d(%%ebp)\n", res->offset);
                        } else {
                            fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", op1->offset);
                            fprintf(out, "\tmovl\t%d(%%ebp), %%edx\n", op2->offset);
                            fprintf(out, "\taddl\t%%edx, %%eax\n");
                            fprintf(out, "\tmovl\t%%eax, %d(%%ebp)\n", res->offset);
                        }
                    }
                    
                } else {
                    if(res->type->bType == t_CHAR) {
                        fprintf(out, "\tmovzbl\t%d(%%ebp), %%eax\n", op1->offset);
                        fprintf(out, "\tmovzbl\t%s, %%edx\n", arg2.c_str());
                        fprintf(out, "\taddl\t%%edx, %%eax\n");
                        fprintf(out, "\tmovb\t%%al, %d(%%ebp)\n", res->offset);
                    } else {
                        fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", op1->offset);
                        fprintf(out, "\tmovl\t$%s, %%edx\n", arg2.c_str());
                        fprintf(out, "\taddl\t%%edx, %%eax\n");
                        fprintf(out, "\tmovl\t%%eax, %d(%%ebp)\n", res->offset);   
                    }
                }
            }
            break;
        case(OP_MINUS):
            {
                symEntry * res = currentSymTab->lookUp(result);
                symEntry * op1 = currentSymTab->lookUp(arg1);
                if(currentSymTab->isPresent(arg2)) {
                    symEntry * op2 = currentSymTab->lookUp(arg2);
                    if(res->type->bType == t_CHAR) {
                        fprintf(out, "\tmovzbl\t%d(%%ebp), %%eax\n", op1->offset);
                        fprintf(out, "\tmovzbl\t%d(%%ebp), %%edx\n", op2->offset);
                        fprintf(out, "\tsubl\t%%edx, %%eax\n");
                        fprintf(out, "\tmovb\t%%al, %d(%%ebp)\n", res->offset);
                    } else {
                        fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", op1->offset);
                        fprintf(out, "\tmovl\t%d(%%ebp), %%edx\n", op2->offset);
                        fprintf(out, "\tsubl\t%%edx, %%eax\n");
                        fprintf(out, "\tmovl\t%%eax, %d(%%ebp)\n", res->offset);
                    }
                } else {
                    if(res->type->bType == t_CHAR) {
                        fprintf(out, "\tmovzbl\t%d(%%ebp), %%eax\n", op1->offset);
                        fprintf(out, "\tmovzbl\t%s, %%edx\n", arg2.c_str());
                        fprintf(out, "\tsubl\t%%edx, %%eax\n");
                        fprintf(out, "\tmovb\t%%al, %d(%%ebp)\n", res->offset);
                    } else {
                        fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", op1->offset);
                        fprintf(out, "\tmovl\t$%s, %%edx\n", arg2.c_str());
                        fprintf(out, "\tsubl\t%%edx, %%eax\n");
                        fprintf(out, "\tmovl\t%%eax, %d(%%ebp)\n", res->offset);   
                    }
                }
            }

            break;
        case(OP_MULT):
            {
                symEntry * res = currentSymTab->lookUp(result);
                symEntry * op1 = currentSymTab->lookUp(arg1);
                if(currentSymTab->isPresent(arg2)) {
                    symEntry * op2 = currentSymTab->lookUp(arg2);
                    if(res->type->bType == t_CHAR) {
                        fprintf(out, "\tmovzbl\t%d(%%ebp), %%eax\n", op1->offset);
                        fprintf(out, "\tmovzbl\t%d(%%ebp), %%edx\n", op2->offset);
                        fprintf(out, "\timull\t%%edx, %%eax\n");
                        fprintf(out, "\tmovb\t%%al, %d(%%ebp)\n", res->offset);
                    } else {
                        fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", op1->offset);
                        fprintf(out, "\tmovl\t%d(%%ebp), %%edx\n", op2->offset);
                        fprintf(out, "\timull\t%%edx, %%eax\n");
                        fprintf(out, "\tmovl\t%%eax, %d(%%ebp)\n", res->offset);
                    }
                } else {
                    if(res->type->bType == t_CHAR) {
                        fprintf(out, "\tmovzbl\t%d(%%ebp), %%eax\n", op1->offset);
                        fprintf(out, "\tmovzbl\t$%s, %%edx\n", arg2.c_str());
                        fprintf(out, "\timull\t%%edx, %%eax\n");
                        fprintf(out, "\tmovb\t%%al, %d(%%ebp)\n", res->offset);
                    } else {
                        fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", op1->offset);
                        fprintf(out, "\tmovl\t$%s, %%edx\n", arg2.c_str());
                        fprintf(out, "\timull\t%%edx, %%eax\n");
                        fprintf(out, "\tmovl\t%%eax, %d(%%ebp)\n", res->offset);
                    }
                }
            }
            break;
        case(OP_DIV):
            {
                symEntry * res = currentSymTab->lookUp(result);
                symEntry * op1 = currentSymTab->lookUp(arg1);
                symEntry * op2 = currentSymTab->lookUp(arg2);
                if(res->type->bType == t_CHAR) {
                    fprintf(out, "\tmovzbl\t%d(%%ebp), %%eax\n", op1->offset);
                    fprintf(out, "\tmovzbl\t%d(%%ebp), %%ecx\n", op2->offset);
                    fprintf(out, "\tcltd\n");
                    fprintf(out, "\tidivl\t%%ecx\n");
                    fprintf(out, "\tmovb\t%%al, %d(%%ebp)\n", res->offset);
                } else {
                    fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", op1->offset);
                    fprintf(out, "\tmovl\t%d(%%ebp), %%ecx\n", op2->offset);
                    fprintf(out, "\tcltd\n");
                    fprintf(out, "\tidivl\t%%ecx\n");
                    fprintf(out, "\tmovl\t%%eax, %d(%%ebp)\n", res->offset);
                }
            }
            break;
        case(OP_MOD):
            {
                symEntry * res = currentSymTab->lookUp(result);
                symEntry * op1 = currentSymTab->lookUp(arg1);
                symEntry * op2 = currentSymTab->lookUp(arg2);
                if(res->type->bType == t_CHAR) {
                    fprintf(out, "\tmovzbl\t%d(%%ebp), %%eax\n", op1->offset);
                    fprintf(out, "\tmovzbl\t%d(%%ebp), %%ecx\n", op2->offset);
                    fprintf(out, "\tcltd\n");
                    fprintf(out, "\tidivl\t%%ecx\n");
                    fprintf(out, "\tmovl\t%%edx, %%eax\n");
                    fprintf(out, "\tmovb\t%%al, %d(%%ebp)\n", res->offset);
                } else {
                    fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", op1->offset);
                    fprintf(out, "\tmovl\t%d(%%ebp), %%ecx\n", op2->offset);
                    fprintf(out, "\tcltd\n");
                    fprintf(out, "\tidivl\t%%ecx\n");
                    fprintf(out, "\tmovl\t%%edx, %d(%%ebp)\n", res->offset);
                }
            }
            break;
        case(OP_UMINUS):
            {
                symEntry * res = currentSymTab->lookUp(result);
                symEntry * op1 = currentSymTab->lookUp(arg1);
                if(res->type->bType == t_CHAR) {
                    fprintf(out, "\tmovzbl\t%d(%%ebp), %%eax\n", op1->offset);
                    fprintf(out, "\tnegl\t%%eax\n");
                    fprintf(out, "\tmovb\t%%al, %d(%%ebp)\n", res->offset);
                } else {
                    fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", op1->offset);
                    fprintf(out, "\tnegl\t%%eax\n");
                    fprintf(out, "\tmovl\t%%eax, %d(%%ebp)\n", res->offset);
                }
            }
            break;
        case(OP_COPY):
            {
                symEntry * res = currentSymTab->lookUp(result);
                if(currentSymTab->isPresent(arg1)) {
                    symEntry * op1 = currentSymTab->lookUp(arg1);
                    if(res->type->bType == t_CHAR) {
                        fprintf(out, "\tmovzbl\t%d(%%ebp), %%eax\n", op1->offset);
                        fprintf(out, "\tmovb\t%%al, %d(%%ebp)\n", res->offset);
                    } else if(op1->type->bType == t_ARR) {
                        fprintf(out, "\tleal\t%d(%%ebp), %%eax\n", op1->offset);
                        fprintf(out, "\tmovl\t%%eax, %d(%%ebp)\n", res->offset);
                    } else {
                        fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", op1->offset);
                        fprintf(out, "\tmovl\t%%eax, %d(%%ebp)\n", res->offset);
                    }
                } else {
                    if(res->type->bType == t_CHAR) {
                        fprintf(out, "\tmovb\t$%s, %%al\n", arg1.c_str());
                        fprintf(out, "\tmovb\t%%al, %d(%%ebp)\n", res->offset);
                    } else {
                        fprintf(out, "\tmovl\t$%s, %%eax\n", arg1.c_str());
                        fprintf(out, "\tmovl\t%%eax, %d(%%ebp)\n", res->offset);   
                    } 
                }
            }
            break;
        case(OP_T):
            break;
        case(OP_F):
            break;
        case(OP_LT):
            {
                int idx = atoi(result.c_str());
                symEntry * op1 = currentSymTab->lookUp(arg1);
                symEntry * op2 = currentSymTab->lookUp(arg2);
                if(op1->type->bType == t_CHAR) {
                    fprintf(out, "\tmovzbl\t%d(%%ebp), %%eax\n", op2->offset);
                    fprintf(out, "\tcmpb\t%%al, %d(%%ebp)\n", op1->offset);
                    fprintf(out, "\tjl\t\t.L%d\n", quad.quad_v[idx].labelIdx);
                } else {
                    fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", op2->offset);
                    fprintf(out, "\tcmpl\t%%eax, %d(%%ebp)\n", op1->offset);
                    fprintf(out, "\tjl\t\t.L%d\n", quad.quad_v[idx].labelIdx);
                }
            }
            break;
        case(OP_LTE):
            {
                int idx = atoi(result.c_str());
                symEntry * op1 = currentSymTab->lookUp(arg1);
                symEntry * op2 = currentSymTab->lookUp(arg2);
                if(op1->type->bType == t_CHAR) {
                    fprintf(out, "\tmovzbl\t%d(%%ebp), %%eax\n", op2->offset);
                    fprintf(out, "\tcmpb\t%%al, %d(%%ebp)\n", op1->offset);
                    fprintf(out, "\tjle\t\t.L%d\n", quad.quad_v[idx].labelIdx);
                } else {
                    fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", op2->offset);
                    fprintf(out, "\tcmpl\t%%eax, %d(%%ebp)\n", op1->offset);
                    fprintf(out, "\tjle\t\t.L%d\n", quad.quad_v[idx].labelIdx);
                }
            }
            break;
        case(OP_GT):
            {
                int idx = atoi(result.c_str());
                symEntry * op1 = currentSymTab->lookUp(arg1);
                symEntry * op2 = currentSymTab->lookUp(arg2);
                if(op1->type->bType == t_CHAR) {
                    fprintf(out, "\tmovzbl\t%d(%%ebp), %%eax\n", op2->offset);
                    fprintf(out, "\tcmpb\t%%al, %d(%%ebp)\n", op1->offset);
                    fprintf(out, "\tjg\t\t.L%d\n", quad.quad_v[idx].labelIdx);
                } else {
                    fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", op2->offset);
                    fprintf(out, "\tcmpl\t%%eax, %d(%%ebp)\n", op1->offset);
                    fprintf(out, "\tjg\t\t.L%d\n", quad.quad_v[idx].labelIdx);
                }
            }
            break;
        case(OP_GTE):
            {
                int idx = atoi(result.c_str());
                symEntry * op1 = currentSymTab->lookUp(arg1);
                symEntry * op2 = currentSymTab->lookUp(arg2);
                if(op1->type->bType == t_CHAR) {
                    fprintf(out, "\tmovzbl\t%d(%%ebp), %%eax\n", op2->offset);
                    fprintf(out, "\tcmpb\t%%al, %d(%%ebp)\n", op1->offset);
                    fprintf(out, "\tjge\t\t.L%d\n", quad.quad_v[idx].labelIdx);
                } else {
                    fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", op2->offset);
                    fprintf(out, "\tcmpl\t%%eax, %d(%%ebp)\n", op1->offset);
                    fprintf(out, "\tjge\t\t.L%d\n", quad.quad_v[idx].labelIdx);
                }
            }
            break;
        case(OP_EQ):
            {
                int idx = atoi(result.c_str());
                symEntry * op1 = currentSymTab->lookUp(arg1);
                symEntry * op2 = currentSymTab->lookUp(arg2);
                if(op1->type->bType == t_CHAR) {
                    fprintf(out, "\tmovzbl\t%d(%%ebp), %%eax\n", op2->offset);
                    fprintf(out, "\tcmpb\t%%al, %d(%%ebp)\n", op1->offset);
                    fprintf(out, "\tje\t\t.L%d\n", quad.quad_v[idx].labelIdx);
                } else {
                    fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", op2->offset);
                    fprintf(out, "\tcmpl\t%%eax, %d(%%ebp)\n", op1->offset);
                    fprintf(out, "\tje\t\t.L%d\n", quad.quad_v[idx].labelIdx);
                }
            }
            break;
        case(OP_NEQ):
            {
                int idx = atoi(result.c_str());
                symEntry * op1 = currentSymTab->lookUp(arg1);
                symEntry * op2 = currentSymTab->lookUp(arg2);
                if(op1->type->bType == t_CHAR) {
                    fprintf(out, "\tmovzbl\t%d(%%ebp), %%eax\n", op2->offset);
                    fprintf(out, "\tcmpb\t%%al, %d(%%ebp)\n", op1->offset);
                    fprintf(out, "\tjne\t\t.L%d\n", quad.quad_v[idx].labelIdx);
                } else {
                    fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", op2->offset);
                    fprintf(out, "\tcmpl\t%%eax, %d(%%ebp)\n", op1->offset);
                    fprintf(out, "\tjne\t\t.L%d\n", quad.quad_v[idx].labelIdx);
                }
            }
            break;
        case(OP_INT2DBL):
            break;
        case(OP_DBL2INT):
            break;
        case(OP_INT2CHAR):
            break;
        case(OP_CHAR2INT):
            break;
        case(OP_L_VAL_AT):
            {
                symEntry * res = currentSymTab->lookUp(result);
                symEntry * op1 = currentSymTab->lookUp(arg1);
                if(op1->type->bType == t_CHAR) {
                    fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", res->offset);
                    fprintf(out, "\tmovzbl\t%d(%%ebp), %%edx\n", op1->offset);
                    fprintf(out, "\tmovb\t%%dl, (%%eax)\n");
                } else {
                    fprintf(out, "\tmovl\t%d(%%ebp), %%edx\n", op1->offset);
                    fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", res->offset);
                    fprintf(out, "\tmovl\t%%edx, (%%eax)\n");
                }
            }
            break;
        case(OP_R_VAL_AT):
            {
                symEntry * res = currentSymTab->lookUp(result);
                symEntry * op1 = currentSymTab->lookUp(arg1);
                if(res->type->bType == t_CHAR) {
                    fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", op1->offset);
                    fprintf(out, "\tmovzbl\t(%%eax), %%eax\n");
                    fprintf(out, "\tmovb\t%%al, %d(%%ebp)\n", res->offset);
                } else {
                    fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", op1->offset);
                    fprintf(out, "\tmovl\t(%%eax), %%eax\n");
                    fprintf(out, "\tmovl\t%%eax, %d(%%ebp)\n", res->offset);
                }
            }
            break;
        case(OP_L_INDEX):
            {
                symEntry * res = currentSymTab->lookUp(result);
                symEntry * op1 = currentSymTab->lookUp(arg1);
                symEntry * op2 = currentSymTab->lookUp(arg2);

                fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", op1->offset);
                fprintf(out, "\tmovl\t%d(%%ebp), %%edx\n", op2->offset);
                if(res->offset < 0) fprintf(out, "\tmovl\t%%edx, %d(%%ebp, %%eax)\n", res->offset);
                else {
                    fprintf(out, "\tmovl\t%d(%%ebp), %%ecx\n", res->offset);
                    fprintf(out, "\tmovl\t%%edx, (%%ecx, %%eax)\n");
                }
            }
            break;
        case(OP_R_INDEX):
            {
                symEntry * res = currentSymTab->lookUp(result);
                symEntry * op1 = currentSymTab->lookUp(arg1);
                symEntry * op2 = currentSymTab->lookUp(arg2);

                fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", op2->offset);
                if(op1->offset < 0) fprintf(out, "\tmovl\t%d(%%ebp, %%eax), %%edx\n", op1->offset);
                else {
                    fprintf(out, "\tmovl\t%d(%%ebp), %%ecx\n", op1->offset);
                    fprintf(out, "\tmovl\t(%%ecx, %%eax), %%edx\n");
                }
                fprintf(out, "\tmovl\t%%edx, %d(%%ebp)\n", res->offset);
            }
            break;
        case(OP_ADDR):
            {
                symEntry * res = currentSymTab->lookUp(result);
                symEntry * op1 = currentSymTab->lookUp(arg1);
                fprintf(out, "\tleal\t%d(%%ebp), %%eax\n", op1->offset);
                fprintf(out, "\tmovl\t%%eax, %d(%%ebp)\n", res->offset);
            }
            
            break;
        case(OP_PARAM):
            {
                if(currentSymTab->isPresent(result)) {
                    symEntry * res = currentSymTab->lookUp(result);
                    if(res->type->bType == t_CHAR) {
                        fprintf(out, "\tmovzbl\t%d(%%ebp), %%eax\n", res->offset);
                        fprintf(out, "\tpushl\t%%eax\n");
                    } else if(res->type->bType == t_ARR) {
                        fprintf(out, "\tleal\t%d(%%ebp), %%eax\n", res->offset);
                        fprintf(out, "\tpushl\t%%eax\n");
                    } else {
                        fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", res->offset);
                        fprintf(out, "\tpushl\t%%eax\n");
                    }
                } else {
                    fprintf(out, "\tpushl\t$%s\n", result.c_str());
                }
            }
            break;
        case(OP_GOTO_O):
            {
                int idx = atoi(result.c_str());
                fprintf(out, "\tjmp\t\t.L%d\n", quad.quad_v[idx].labelIdx);
            }
            break;
        case(OP_CALL):
            {
                symEntry * func = globalSymTab->lookUp(arg1);
                symEntry * res = currentSymTab->lookUp(result);
                fprintf(out, "\tcall\t%s\n", arg1.c_str());
                fprintf(out, "\taddl\t$%d, %%esp\n", func->nestedTable->sizeParam);
                if(res->type->bType != t_VOID) {
                    if(res->type->bType == t_CHAR) {
                        fprintf(out, "\tmovb\t%%al, %d(%%ebp)\n", res->offset);
                    } else if(res->type->bType == t_ARR || res->type->bType == t_PTR) {
                        fprintf(out, "\tleal\t%%eax, %d(%%ebp)\n", res->offset);
                    } else {
                        fprintf(out, "\tmovl\t%%eax, %d(%%ebp)\n", res->offset);
                    }
                }
            }
            break;
        case(OP_RETURN):
            fprintf(out, "\tleave\n");
            fprintf(out, "\tret\n");
            break;
        case(OP_RETURN_VAL):
            {
                symEntry * res = currentSymTab->lookUp(result);
                if(res->type->bType == t_CHAR) {
                    fprintf(out, "\tmovzbl\t%d(%%ebp), %%eax\n", res->offset);
                } else {
                    fprintf(out, "\tmovl\t%d(%%ebp), %%eax\n", res->offset);
                }
                fprintf(out, "\tleave\n");
                fprintf(out, "\tret\n");
            }
            break;
        case(OP_BW_NOT):
            break;
        case(OP_SHL):
            break;
        case(OP_SHR):
            break;
        case(OP_BW_AND):
            break;
        case(OP_BW_XOR):
            break;
        case(OP_BW_OR):
            break;
        case(OP_FUNC_START):
            currentSymTab = globalSymTab->lookUp(result)->nestedTable;
            fprintf(out, "\t.globl\t%s\n", result.c_str());
            fprintf(out, "\t.type\t%s, @function\n", result.c_str());
            fprintf(out, "%s:\n", result.c_str());
            fprintf(out, "\tpushl\t%%ebp\n");
            fprintf(out, "\tmovl\t%%esp, %%ebp\n");
            fprintf(out, "\tsubl\t$%d, %%esp\n", currentSymTab->sizeLocal);
            break;
        case(OP_FUNC_END):
            fprintf(out, "\tleave\n");
            fprintf(out, "\tret\n");
            fprintf(out, "\t.size\t%s, .-%s\n", result.c_str(), result.c_str());
            break;
        default:
            printf("Error ! Unknown opcodeType.\n");
            exit(-1);
    }
}

// node constructors
node::node(int idx) : qIdx(idx), next(NULL) {}

node::node() : next(NULL) {}

// List constructors
List::List(int idx) {
    head = new node(idx);
    tail = head;
}

List::List() {
    head = tail = NULL;
}

// print the list (for debugging purpose)
void List::print() {
    node * ptr = head;
    while(ptr != NULL) {
        printf("%d ", ptr->qIdx);
        ptr = ptr->next;
    }
    printf("\n");
}

// merge two lists
List * mergeList(List * l1, List * l2) {
    // check if one of the list is NULL
    if(l1 == NULL || l1->head == NULL) return l2;
    if(l2 == NULL || l2->head == NULL) return l1;
    l1->tail->next = l2->head;
    l1->tail = l2->tail;
    return l1;
}

// delete the allocated memory
void List::clear() {
    node * ptr = head, * oldPtr;
    while(ptr != NULL) {
        oldPtr = ptr;
        ptr = ptr->next;
        delete oldPtr;
    }
    head = NULL;
    tail = NULL;
}

// Backpatch the list with given address
void backPatch(List * & p, int addr) {
    if(p != NULL && p->head != NULL) {
        node * ptr = p->head;
        while(ptr != NULL) {
            quad.quad_v[ptr->qIdx].setTarget(addr); 
            ptr = ptr->next;
        }
        p->clear();
        p = NULL;
    }

}

// Print all the quads generated
void printAllQuads(FILE * out) {
    for(int i = 0; i < (int)quad.quad_v.size(); ++i) {
        fprintf(out, "%3d. ", i); 
        quad.quad_v[i].print(out);
    }
}

vector <bool> markAllLabels() {
    int labelCounter = 0;
    vector <bool> mark(quad.quad_v.size(), false);
    for(int i = 0; i < (int)quad.quad_v.size(); ++i) {
        opcodeType op = quad.quad_v[i].op;
        if( op == OP_LT ||
            op == OP_GT ||
            op == OP_LTE ||
            op == OP_GTE ||
            op == OP_EQ ||
            op == OP_NEQ ||
            op == OP_GOTO_O
        ) {
            int idx = atoi(quad.quad_v[i].result.c_str());
            mark[idx] = true;
        }
    }

    for(int i = 0; i < (int)quad.quad_v.size(); ++i) {
        if(mark[i]) quad.quad_v[i].labelIdx = labelCounter++;
    }
    return mark;
}

void genTargetCode(FILE * out) {

    for(int i = 0; i < (int)globalSymTab->entries.size(); ++i) {
        if(globalSymTab->entries[i]->nestedTable != NULL) {
            currentSymTab = globalSymTab->entries[i]->nestedTable;
            break;
        }
    }

    for(int i = 0; i < (int)strLabels.size(); ++i) {
        string label = ".LC" + i2s(i);
        fprintf(out, "%s:\n", label.c_str());
        fprintf(out, "\t.string\t%s\n", strLabels[i].c_str());
    }
    if(strLabels.size() > 0) {
        fprintf(out, "\t.text\n");
    }
    vector <bool> mark = markAllLabels();

    for(int j = 0; j < (int)quad.quad_v.size(); ++j) {
        if(quad.quad_v[j].op == OP_FUNC_START) {
            currentSymTab = globalSymTab->lookUp(quad.quad_v[j].result)->nestedTable;
            break;
        }
    }
    for(int i = 0; i < (int)quad.quad_v.size(); ++i) {
        if(mark[i]) {
            fprintf(out, ".L%d:\n", quad.quad_v[i].labelIdx);
        }
        quad.quad_v[i].genTargetCode(out);
        if(quad.quad_v[i].op == OP_FUNC_END) {
            for(int j = i + 1; j < (int)quad.quad_v.size(); ++j) {
                if(quad.quad_v[j].op == OP_FUNC_START) {
                    currentSymTab = globalSymTab->lookUp(quad.quad_v[j].result)->nestedTable;
                    break;
                }
            }
        }
    }   
}

// convert int to string
string i2s(int n) {
    char tmp[10];
    sprintf(tmp, "%d", n);
    return tmp;
}

// check the type of two expressions
// if they are not equal convert them accordingly
// for assignment operation, e2 must be converted to e1 type 
// otherwise, they should be converted to higher data type
bool typeCheck(exp_t * e1, exp_t * e2, bool isAssignment) {
    if(!areEqual(e1->type, e2->type)) {
        exp_t * e3 = new exp_t();
        // convert lower type to higher
        if(!isAssignment && e1->type->bType < e2->type->bType) {
            // Special case for bool to int conversion
            if(e1->type->bType == t_BOOL && e2->type->bType == t_INT) {
                convBool2Int(e1);
                return true;
            } 
            e3->loc = currentSymTab->genTemp(new type_t(*(e2->type)));
            e3->type = e3->type;
            // generate a quad with opcode for conversion
            if(e1->type->bType == t_INT && e2->type->bType == t_DOUBLE) {
                quad.emit(quadEntry(OP_INT2DBL, e3->loc->name, e1->loc->name));

            } else if(e1->type->bType == t_INT && e2->type->bType == t_CHAR) {
                quad.emit(quadEntry(OP_INT2CHAR, e3->loc->name, e1->loc->name));

            } else if(e1->type->bType == t_CHAR && e2->type->bType == t_INT) {
                quad.emit(quadEntry(OP_CHAR2INT, e3->loc->name, e1->loc->name));

            } else if(e1->type->bType == t_DOUBLE && e2->type->bType == t_INT) {
                quad.emit(quadEntry(OP_DBL2INT, e3->loc->name, e1->loc->name));

            } else return false;
            e1->loc = e3->loc;
        } else {
            if(e2->type->bType == t_BOOL && e1->type->bType == t_INT) {
                convBool2Int(e2);
                return true;
            } 
            e3->loc = currentSymTab->genTemp(new type_t(*(e1->type)));
            e3->type = e3->type;
            if(e1->type->bType == t_INT && e2->type->bType == t_DOUBLE) {
                quad.emit(quadEntry(OP_DBL2INT, e3->loc->name, e2->loc->name));

            } else if(e1->type->bType == t_INT && e2->type->bType == t_CHAR) {
                quad.emit(quadEntry(OP_CHAR2INT, e3->loc->name, e2->loc->name));

            } else if(e1->type->bType == t_CHAR && e2->type->bType == t_INT) {
                quad.emit(quadEntry(OP_INT2CHAR, e3->loc->name, e2->loc->name));

            } else if(e1->type->bType == t_DOUBLE && e2->type->bType == t_INT) {
                quad.emit(quadEntry(OP_INT2DBL, e3->loc->name, e2->loc->name));

            } else return false;
            e2->loc = e3->loc; 
        }
    }
    return true;
}

// convert an expression to bool type
void conv2Bool(exp_t * e) {
    if(e->type->bType != t_BOOL) {
        // create true list and false list
        e->falseList = new List(quad.nextInstr);
        quad.emit(quadEntry(OP_EQ, "", e->loc->name, "0"));
        e->trueList = new List(quad.nextInstr);
        quad.emit(quadEntry(OP_GOTO_O, ""));
    }
}

// convert bool to int
void convBool2Int(exp_t * b) {
    if(b->type->bType == t_BOOL) {
        exp_t * e = new exp_t();
        e->loc = currentSymTab->genTemp(new type_t(t_INT));
        e->type = e->loc->type;
        backPatch(b->trueList, quad.nextInstr);
        quad.emit(quadEntry(OP_COPY, e->loc->name, "1"));
        backPatch(b->falseList, quad.nextInstr);
        quad.emit(quadEntry(OP_COPY, e->loc->name, "0"));
        b->loc = e->loc;
        b->type = e->type;
    }
}

// check the types of parameter
bool paramTypeCheck(exp_t * e1, exp_t * e2) {
    if((e1->type->bType == t_ARR || e1->type->bType == t_PTR)
    && (e2->type->bType == t_ARR || e2->type->bType == t_PTR)) {
        return true;
    }
    return typeCheck(e1, e2, true);
}

// check the parameters of a function with the arguments
bool checkParams(exp_t e, vector <exp_t *> * args) {
    int paramN = 0;
    vector <symEntry *> & v = e.loc->nestedTable->entries;
    for(int i = 1; i < (int)v.size(); ++i) {
        if(v[i]->scope != "param") continue;
        if(paramN >= (int)args->size()) return false;
        exp_t e1;
        e1.type = v[i]->type;
        exp_t * e2 = (*args)[paramN];
        ++paramN;
        if(!paramTypeCheck(&e1, e2)) return false;
    }
    return paramN == (int)args->size();
}

void adjustOffset(symTable * sym) {
    int paramOffset = +8;
    int localOffset = 0;
    // sym->entries[0]->offset = +4;
    for(int i = 0; i < (int)sym->entries.size(); ++i) {
        if(sym->entries[i]->scope == "param") {
            sym->entries[i]->offset = paramOffset;
            if(sym->entries[i]->type->bType == t_CHAR) sym->entries[i]->size = SIZE_OF_INT;
            paramOffset += sym->entries[i]->size;
        } else if(sym->entries[i]->scope == "local" || sym->entries[i]->scope == "temp") {
            localOffset -= sym->entries[i]->size;
            sym->entries[i]->offset = localOffset;
        }
    }
    sym->sizeLocal = ((abs(localOffset) + 15) / 16) * 16;
    sym->sizeParam = abs(paramOffset) - 8;
}

int main() {
    // yydebug = 1;
    yyparse();
    for(int i = 0; i < (int)globalSymTab->entries.size(); ++i) {
        adjustOffset(globalSymTab->entries[i]->nestedTable);
    }
    //Uncomment below portion to print all symbol tables

    globalSymTab->print();
    for(int i = 0; i < (int)globalSymTab->entries.size(); ++i) {
        if(globalSymTab->entries[i]->nestedTable != NULL) {
            globalSymTab->entries[i]->nestedTable->print();
        }
    }
    printAllQuads(stdout);
    //genTargetCode(stdout);
    return 0;
}